Let - do define a constant, it means you can use the constant multiple places but assign a value once only
Var - do define a variable. 

let, var - types can be inferred by compiler based on the value assigned. 

Values are never implicitly converted to another type. 
If you need to convert a value to a different type, explicitly make an instance of the desired type.

Control flow 
if, switch -> make conditions 
for-in, while, repeat-while - make loops 
if let - to check the optionals have value or not 

Optional -> value or nil 
? -> mark after the type of a value to mark the value as optional. 
?? -> Provided default value

When working with optional values, you can write ? before operations like methods, properties, 
and subscripting. If the value before the ? is nil, everything after the ? is ignored and the value of the whole 
expression is nil. Otherwise, the optional value is unwrapped, and everything after the ? acts on the unwrapped value. 
In both cases, the value of the whole expression is an optional value.

let city: String ?
let defaultCity = "London"
let greetings = "Hello from \(city ?? defaultCity)".

Switches support any kind of data and a wide variety of comparison 
operations — they aren’t limited to integers and tests for equality.

for-in -> Iterate over dictionary 

Dictionaries are unordered collections, so their keys and values are iterated over in an arbitrary order. 

Use while -> to repeat a block of code until a condition changes. 

Range Index -> ..< to make a range that omits its upper value 
... to make a range that includes both values.

Tuple -> make a compound value. To return multiple values from Function. 

Functions - can be nested, are first-class type - function can return another function as its value. Function can take another function 
as its argument. 

Closure - Blocks of code that can be called later. 
Closure has access to variables, functions that were available in the scope where the closure was created, 
even if the closure is in different scope when executed. 

Class - class followed by the class's name create a class. 
A property declaration in a class is written the same way as a constant or variable declaration, except it's context of a class. 

Create an instance of a class by putting parentheses after the class name. Use dot syntax to access the properties and 
methods of the instance.

init -> Initialiser helps to set up the class when an instance is created. 
deinit -> Use deinit to create a deinitializer if you need to perform some cleanup before the object is deallocated.

Methods on a subclass that override the superclass’s implementation are marked with override

Properties can have getter and setter methods. 

    var perimeter: Double {
        get {
             return 3.0 * sideLength
        }
        set {
            sideLength = newValue / 3.0
        }
    }

In the setter for perimeter, the new value has the implicit name newValue. 
You can provide an explicit name in parentheses after set.

If you don’t need to compute the property but still need to provide code that’s run before and after setting a new value, 
use willSet and didSet. 

enum -> creates an enumeration. 
Can have methods associates with it. 
By default, Swift assigns the raw values starting at zero and incrementing by one each time, but you can change this 
behavior by explicitly specifying values.

You can also use strings or floating-point numbers as the raw type of an enumeration. 
Use the rawValue property to access the raw value of an enumeration case.

Use the init?(rawValue:) initializer to make an instance of an enumeration from a raw value. 
It returns either the enumeration case matching the raw value or nil if there’s no matching Rank.

Raw and Associated values in enum. 
If an enumeration has raw values, those values are determined as part of the declaration, which means every instance of a particular enumeration case always has the same raw value. 
Another choice for enumeration cases is to have values associated with the case — these values are determined when you make the instance, 
and they can be different for each instance of an enumeration case. You can think of the associated values as behaving like stored properties of the enumeration case instance.

structure -> 
Use struct to create a structure.
Structures support many of the same behaviors as classes, including methods and initializers. 
One of the most important differences between structures and classes is that structures are always
copied when they’re passed around in your code, but classes are passed by reference.

Concurrency -> 
Use async to mark a function that runs asynchronously.
func fetchUserID(from server: String) async -> Int {
    if server == "primary" {
        return 97
    }
    return 501
}

You mark a call to an asynchronous function by writing await in front of it.

func fetchUsername(from server: String) async -> String {
    let userID = await fetchUserID(from: server)
    if userID == 501 {
        return "John Appleseed"
    }
    return "Guest"
}

Use "async let" to call asynchronous function, letting it run in parallel with other asynchronous code. 
When you use the value it returns, write await. 
func connectUser(to server: String) async {
    async let userID = fetchUserID(from: server)
    async let username = fetchUsername(from: server)
    let greeting = await "Hello \(username), user ID \(userID)"
    print(greeting)
}

Use "Task" to call asynchronous functions from synchronous code, without waiting for them to return. 
Task {
    await connectUser(to: "primary")
}

Use "task groups" to structure concurrent code. 
let userIDs = await withTaskGroup(of: Int.self) { group in
    for server in ["primary", "secondary", "development"] {
        group.addTask {
            return await fetchUserID(from: server)
        }
    }


    var results: [Int] = []
    for await result in group {
        results.append(result)
    }
    return results
}

Actors -> Simillar to Class, except they ensure that different asynchronous 
functions can safely interact with an instance of the same actor at the same time.

actor ServerConnection {
    var server: String = "primary"
    private var activeUsers: [Int] = []
    func connect() async -> Int {
        let userID = await fetchUserID(from: server)
        // ... communicate with server ...
        activeUsers.append(userID)
        return userID
    }
}
When you call a method on an actor or access one of its properties,
you mark that code with await to indicate that it might have to wait for other code that’s already running on the actor to finish.
let server = ServerConnection()

let userID = await server.connect()

Protocols -> Use protocol to declare a protocol. 
Classes, enumerations, and structures can all adopt protocols.

You can use an extension to add protocol conformance to a type that’s declared elsewhere, 
or even to a type that you imported from a library or framework.

You can use a protocol name just like any other named type — for example, to create a collection of objects that have different types but that all conform to a single protocol. 
When you work with values whose type is a boxed protocol type, methods outside the protocol definition aren’t available.

Error Handling
You represent errors using any type that adopts the Error protocol.

enum PrinterError: Error {
    case outOfPaper
    case noToner
    case onFire
}
Use throw to throw an error and throws to mark a function that can throw an error. 

If you throw an error in a function, the function returns immediately and the code that called the function handles the error.

Various ways to handle errors.
1. do-catch block 
Inside the do block, you mark code that can throw an error by writing try in front of it. 
Inside the catch block, the error is automatically given the name error unless you give it a different name.

2. Use try? - to convert the result to an optional. 
If the function throws an error, the specific error is discarded and the result is nil. 
Otherwise, the result is an optional containing the value that the function returned.

Defer:
Use defer to write a block of code that’s executed after all other code in the function, just before the function returns. 
The code is executed regardless of whether the function throws an error. 
You can use defer to write setup and cleanup code next to each other, even though they need to be executed at different times.

Generics:
Write a name inside brackets to make a generic function or type. 

You can make generic forms of functions and methods, as well as classes, enumerations, and structures.

Assertions and Preconditions:
Assertions and preconditions are checks that happen at runtime. 
You use them to make sure an essential condition is satisfied before executing any further code. 
You use assertions and preconditions to express the assumptions you make and the expectations you have while coding, so you can include them as part of your code. 
Assertions help you find mistakes and incorrect assumptions during development, and preconditions help you detect issues in production.

The difference between assertions and preconditions is in when they’re checked: 
Assertions are checked only in debug builds, but preconditions are checked in both debug and production builds. 
In production builds, the condition inside an assertion isn’t evaluated. 
This means you can use as many assertions as you want during your development process, without impacting performance in production.

let age = -3
assert(age >= 0, "A person's age can't be less than zero.")

precondition(index > 0, "Index must be greater than zero.")




